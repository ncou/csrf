<?php

declare(strict_types=1);

namespace Chiron\Csrf\Middleware;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Chiron\Http\Message\Cookie;
use Chiron\Csrf\Config\CsrfConfig;
use Chiron\Config\SecurityConfig;
use Chiron\Core\Support\Security;
use Chiron\Csrf\Exception\InvalidTokenException;

//https://github.com/cakephp/cakephp/blob/master/src/Http/Middleware/CsrfProtectionMiddleware.php
////https://github.com/Riimu/Kit-CSRF/blob/master/src/CSRFHandler.php#L202

// TODO : gÃ©rer le 'path' dans le cookie header. cf //'path' => $request->getAttribute('webroot'), // https://github.com/cakephp/cakephp/blob/master/src/Http/Middleware/CsrfProtectionMiddleware.php#L331

/**
 * Provides generic CSRF protection using cookie as token storage. Set "csrfToken" attribute to request.
 *
 * @see https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie
 */
final class CsrfTokenMiddleware implements MiddlewareInterface
{
    /**
     * Request attribute name used to store the cookie token used later.
     */
    public const ATTRIBUTE = 'csrfToken';
    /**
     * Length of the token 'id' part in characters.
     */
    public const TOKEN_ID_LENGTH = 16;
    /**
     * Length of the token (id + hmac) characters.
     */
    public const TOKEN_LENGTH = 16 + 40;
    /**
     * Hash algo used in the hmac function.
     * Lenght is 160-bits (20-bytes) it's 40 chars as hexa result.
     */
    public const HASH_FUNCTION_NAME = 'sha1';

    /** @var string */
    private $secretKey;
    /** @var CsrfConfig */
    private $csrfConfig;

    /**
     * @param SecurityConfig $securityConfig
     * @param CsrfConfig $csrfConfig
     */
    public function __construct(SecurityConfig $securityConfig, CsrfConfig $csrfConfig)
    {
        // Secret key (hexa 64 chars) will be used to keyed an hash value used as signature.
        $this->secretKey = $securityConfig->getKey();
        $this->csrfConfig = $csrfConfig;
    }

    /**
     * {@inheritdoc}
     */
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $token = $this->getCookieToken($request);

        if (! $token) {
            // Making new token.
            $token = $this->createToken();
            // Prepare token cookie.
            $cookie = $this->createCookie($token);
        }

        // "cross-site request forgery" issues must be handled by CsrfProtection middleware.
        $response = $handler->handle($request->withAttribute(static::ATTRIBUTE, $token));

        if (isset($cookie)) {
            return $response->withAddedHeader('Set-Cookie', $cookie->toHeaderValue());
        }

        return $response;
    }

    /**
     * Grab the token from the cookie if it's present.
     * Ensure token integrity and throw an http exception if signature fail.
     *
     * @param string $token The CSRF token.
     *
     * @throws InvalidTokenException Remove the altered cookie and throw an Http 412 Precondition-Failed exception.
     *
     * @return null|string
     */
    private function getCookieToken(ServerRequestInterface $request): ?string
    {
        $cookieName = $this->csrfConfig->getCookie();

        $token = $request->getCookieParams()[$cookieName] ?? null;

        // Check if the cookie token hasn't been altered.
        if ($token && ! $this->isTokenValid($token)) {
            // Throw an Http 412 Precondition-Failed exception.
            $exception = new InvalidTokenException();
            // Remove the altered cookie (force the expiration date).
            $expiredCookie = $this->createCookie('')->withExpired();
            $exception->addHeader('Set-Cookie', $expiredCookie->toHeaderValue());

            throw $exception;
        }

        return $token;
    }

    /**
     * Verify that CSRF token was originally generated by the receiving application.
     *
     * @param string $token The CSRF token.
     *
     * @return bool
     */
    private function isTokenValid(string $token): bool
    {
        if (strlen($token) !== self::TOKEN_LENGTH) {
            return false;
        }

        $id = substr($token, 0, self::TOKEN_ID_LENGTH);
        $hmac = substr($token, self::TOKEN_ID_LENGTH);

        $expectedHmac = hash_hmac(self::HASH_FUNCTION_NAME, $id, $this->secretKey);

        return hash_equals($hmac, $expectedHmac);
    }

    /**
     * Create a new token to be used for CSRF protection.
     * Use a 20 bytes hmac value to ensure cookie integrity.
     *
     * @return string
     */
    private function createToken(): string
    {
        $id = Security::generateId(self::TOKEN_ID_LENGTH);
        // Generate a keyed hash value to sign token.
        $hmac = hash_hmac(self::HASH_FUNCTION_NAME, $id, $this->secretKey);

        return $id . $hmac;
    }

    /**
     * Create CSRF cookie.
     *
     * @param string $token
     *
     * @return Cookie
     */
    private function createCookie(string $token): Cookie
    {
        $cookie = Cookie::create(
            $this->csrfConfig->getCookie(),
            $token,
            [
                'expires' => time() + $this->csrfConfig->getCookieLifetime(),
                //'path' => null, //'path' => $request->getAttribute('webroot'), // https://github.com/cakephp/cakephp/blob/master/src/Http/Middleware/CsrfProtectionMiddleware.php#L331
                'secure' => $this->csrfConfig->isCookieSecure(),
                'samesite' => $this->csrfConfig->getSameSite(),
                'httponly' => true,
            ]
        );

        return $cookie;
    }
}
